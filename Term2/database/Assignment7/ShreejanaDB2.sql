CREATE TABLE person_records
(
    PERSON_ID number(10) primary key,
    FIRST_NAME varchar2(50),
    LAST_NAME varchar2(50),
    HIRE_DATE date,
    UPDATED_BY varchar2(20),
    UPDATED_DATE date
);

CREATE OR REPLACE TRIGGER trg_before_person_update
BEFORE UPDATE
  on person_records
  FOR EACH ROW 

DECLARE
    username varchar2(20);

BEGIN

  SELECT USER INTO username FROM dual;
  
  -- Setting updated_by and updated_Date values.
  :NEW.UPDATED_BY := username;
  :NEW.UPDATED_DATE := sysdate;

END;

alter session set nls_date_format = 'DD-MON-YYYY';

INSERT INTO person_records VALUES (101,'Devil','Khedut',sysdate,null,null);
INSERT INTO person_records VALUES (102,'Kanji','Yadav',sysdate,null,null);

select * from person_records;


UPDATE person_records SET first_name = 'David' WHERE person_id = 101;

UPDATE person_records SET first_name = 'Warner' WHERE person_id = 102;



select * from customers;

CREATE TABLE CUSTOMERS( 
   ID   INT NOT NULL, 
   NAME VARCHAR (20) NOT NULL, 
   AGE INT NOT NULL, 
   ADDRESS CHAR (25), 
   SALARY   DECIMAL (18, 2),        
   PRIMARY KEY (ID) 
);

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) 
VALUES (1, 'Ramesh', 32, 'Ahmedabad', 2000.00 );  

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) 
VALUES (2, 'Khilan', 25, 'Delhi', 1500.00 );  

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) 
VALUES (3, 'kaushik', 23, 'Kota', 2000.00 );
  
INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) 
VALUES (4, 'Chaitali', 25, 'Mumbai', 6500.00 ); 
 
INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) 
VALUES (5, 'Hardik', 27, 'Bhopal', 8500.00 );  

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) 
VALUES (6, 'Komal', 22, 'MP', 4500.00 ); 

select * from customers;

set SERVEROUTPUT on;

CREATE OR REPLACE TRIGGER display_salary_changes 
BEFORE DELETE OR INSERT OR UPDATE ON customers 
FOR EACH ROW 
WHEN (NEW.ID > 0) 
DECLARE 
   sal_diff number; 
BEGIN 
   sal_diff := :NEW.salary  - :OLD.salary; 
   dbms_output.put_line('Old salary: ' || :OLD.salary); 
   dbms_output.put_line('New salary: ' || :NEW.salary); 
   dbms_output.put_line('Salary difference: ' || sal_diff); 
END;

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) 
VALUES (7, 'Kriti', 22, 'HP', 7500.00 );

INSERT INTO CUSTOMERS (ID,NAME,AGE,ADDRESS,SALARY) 
VALUES (8, 'Kritika', 22, 'HPD', 8500.00 );

UPDATE customers 
SET salary = salary + 500 
WHERE id = 2; 


--update employees where dept_name = "HR" set dept_name = "Produce";
select * from employees where department_code = 'VG';


CREATE OR REPLACE TRIGGER display_department_changes 
BEFORE DELETE OR INSERT OR UPDATE ON employees 
FOR EACH ROW 
WHEN (NEW.ID > 0) 
DECLARE 
   dept_code varchar(20); 
BEGIN 
   sal_diff := :NEW.salary  - :OLD.salary; 
   dbms_output.put_line('Old salary: ' || :OLD.salary); 
   dbms_output.put_line('New salary: ' || :NEW.salary); 
   dbms_output.put_line('Salary difference: ' || sal_diff); 
END;


--Assignment7
------------------------------


SET SERVEROUTPUT ON;

-- QUESTION 1: Creating nested table type skill_list
CREATE OR REPLACE TYPE skill_list AS TABLE OF VARCHAR2(100);

-- QUESTION 2: Creating the table employees_321 with id having auto-increment
CREATE TABLE employees_321 (
    id NUMBER GENERATED ALWAYS as IDENTITY(START with 1 INCREMENT by 1) PRIMARY KEY,
    name VARCHAR2(100),
    position VARCHAR2(50),
    salary NUMBER(10, 2),
    skills skill_list,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
NESTED TABLE skills STORE AS skills_nested_table;


-- QUESTION 2: Creating the table employees_audit with id having auto-increment
CREATE TABLE employees_audit (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id NUMBER REFERENCES employees_321(id),
    action VARCHAR2(50),
    old_skills skill_list,
    new_skills skill_list,
    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
NESTED TABLE old_skills STORE AS old_skills_nested_table,
NESTED TABLE new_skills STORE AS new_skills_nested_table;


-- inserting the data to the employees table created above
INSERT INTO employees_321(name, position, salary, skills) 
    VALUES('David Smith', 'Accountant', 98754, skill_list('Accounting', 'Book keeping'));

INSERT INTO employees_321(name, position, salary, skills) 
    VALUES('Raman Neth', 'Programmer', 85478, skill_list('Python', 'React'));


-- QUESTION 4: creating trigger that will insert a row whenever an update to
-- the employees' skill are made
CREATE OR REPLACE TRIGGER after_employee_update
AFTER UPDATE ON employees_321
FOR EACH ROW
DECLARE
    v_action VARCHAR2(50) := 'UPDATE';
BEGIN
    IF :OLD.skills IS NOT NULL AND :NEW.skills IS NOT NULL AND :OLD.skills != :NEW.skills THEN
        -- Insert a new record in the audit table
        INSERT INTO employees_audit (
            employee_id, 
            action, 
            old_skills, 
            new_skills, 
            changed_at
        )
        VALUES (
            :OLD.id,
            v_action,
            :OLD.skills,
            :NEW.skills,
            SYSTIMESTAMP
        );

        -- Display the old and new records
        DBMS_OUTPUT.PUT_LINE('Employee ID: ' || :OLD.id);

        DBMS_OUTPUT.PUT_LINE('Old Skills: ');
        FOR i IN 1..:OLD.skills.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE(' - ' || :OLD.skills(i));
        END LOOP;

        DBMS_OUTPUT.PUT_LINE('New Skills: ');
        FOR i IN 1..:NEW.skills.COUNT LOOP
            DBMS_OUTPUT.PUT_LINE(' - ' || :NEW.skills(i));
        END LOOP;

        DBMS_OUTPUT.PUT_LINE('Change Action: ' || v_action);
        DBMS_OUTPUT.PUT_LINE('Change Timestamp: ' || SYSTIMESTAMP);
    END IF;
END;
/
-- EXPLANATION
/* A row level trigger for employees_321 has been created that would fire after 
  updating operation is performed on the table. 

  Once the update query is run for the employee with name Raman Neth, the above
  trigger after_employee_update is fired and it will display the results 
  updating the records
*/


select * from employees_321;

UPDATE employees_321
SET skills = skill_list('Java', 'SQL', 'Python')
WHERE name = 'Raman Neth';



-- Week 11 class examples
------------------------------------------------
SET SERVEROUTPUT ON;

CREATE TABLE emp_log_stmt_updates(
    log_id Number GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, 
    trg_name Varchar2(50), 
    trg_event Varchar2(50)
    );
    
ALTER TABLE emp_log_stmt_updates 
    MODIFY log_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY;

CREATE OR REPLACE TRIGGER stmt_3_trg
BEFORE UPDATE OF salary ON employees
BEGIN 
    INSERT INTO emp_log_stmt_updates (log_id, trg_name, trg_event)
        VALUES (1, 'stmt_3_trg', 'BEFORE-UPDATE');
    DBMS_OUTPUT.PUT_LINE('stmt_3_trg BEFORE UPDATE completed.');
END;


CREATE OR REPLACE TRIGGER stmt_4_trg
BEFORE UPDATE OF salary, department_code ON employees
BEGIN 
    INSERT INTO emp_log_stmt_updates (trg_name, trg_event)
        VALUES ('stmt_4_trg', 'BEFORE-UPDATE');
    DBMS_OUTPUT.PUT_LINE('stmt_4_trg salary completed.');
END;

CREATE OR REPLACE TRIGGER stmt_6_trg
BEFORE UPDATE ON employees
BEGIN
    IF TO_CHAR(SYSDATE,'DY') IN ('SUN','SAT') THEN
        RAISE_APPLICATION_ERROR (-20500,'UPDATE during business hours only');
    END IF;
END;



UPDATE employees
    SET salary = 20000
    WHERE employee_id = 110;
    
UPDATE employees
    SET department_code = 'TR',
    salary = 2100
    WHERE employee_id = 110;


CREATE OR REPLACE TRIGGER row_00_trg
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Employee:' || :OLD.employee_id);
    DBMS_OUTPUT.PUT_LINE('OLD salary: ' || :OLD.department_code);
    DBMS_OUTPUT.PUT_LINE('OLD salary: ' || :NEW.department_code);
    DBMS_OUTPUT.PUT_LINE('OLD salary: ' || :OLD.salary);
    DBMS_OUTPUT.PUT_LINE('New salary: ' || :NEW.salary);
END;

INSERT INTO employees VALUES (99, 'IIT', 45632);


CREATE TABLE log_salary_updates(
    log_id number GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    trg_name varchar(30),
    emp_id number,
    old_salary number(10,2),
    new_salary number(10,2)

);

CREATE OR REPLACE TRIGGER row_1_trg
BEFORE UPDATE OF salary ON employees
FOR EACH ROW
BEGIN
 INSERT INTO log_salary_updates (trg_name, emp_id, old_salary, new_salary)
 VALUES ('row_1_trg', :OLD.employee_id, :OLD.salary, :NEW.salary);
 DBMS_OUTPUT.PUT_LINE ('row_1_trg BEFORE UPDATE completed.');
END;


select * from employees;
select * from emp_log_stmt_updates
order by log_id;

select * from emp

CREATE TABLE emp_log_salary_updates(
    log_id number GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    trg_name varchar(30),
    emp_id number,
    old_salary number(10,2),
    new_salary number(10,2)

);

CREATE TABLE log_dept_updates(
    log_id number GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    trg_name varchar(30),
    emp_id number,
    old_dept number,
    new_dept number

);

CREATE OR REPLACE TRIGGER row_5_trg
AFTER UPDATE OF sal, deptno on emp
FOR EACH ROW
BEGIN 
    IF UPDATING('SAL') THEN
    INSERT INTO log_salary_updates(trg_name, empno, old_salary, new_salary)
        VALUES ('row_5_trg', :OLD.emp_id, :OLD.salary, :NEW.salary);
    END IF;
    IF UPDATING('DEPTNO') THEN
        INSERT INTO log_dept_updates
            (trg_name, emp_id, old_dept, new_dept)
            VALUES ('row_5_trg', :OLD.emp_id, :OLD.deptno, :NEW.deptno);
    END IF;
    DBMS_OUTPUT.PUT_LINE ('Trigger row_5_trg completed.');
EXCEPTION
    WHEN OTHERS THEN
        raise_application_error (-20002,'Invalid update operation.');
END row_5_trg;

select * from log_salary_updates;
select * from log_dept_updates;

drop table emp_log_stmt_updates;



-- Assignment 8
------------------------------------------------

SET SERVEROUTPUT ON

-- creating table players to store information about players
CREATE TABLE players (
    player_id NUMBER PRIMARY KEY,
    player_name VARCHAR2(100),
    games_played NUMBER,
    points_scored NUMBER
);

-- Creating table player_stats to hold aggregated statistics
CREATE TABLE player_stats (
    player_id NUMBER PRIMARY KEY,
    total_games NUMBER,
    total_points NUMBER
);

-- create a compound trigger that will fire INSERT, UPDATE, or DELETE operations on players table

CREATE OR REPLACE TRIGGER trg_player_stats
FOR INSERT OR UPDATE OR DELETE ON players
COMPOUND TRIGGER

  -- Declare collection type and variables
  v_dml_type VARCHAR2(10);
  TYPE player_id_table IS TABLE OF players.player_id%TYPE;
  v_player_ids player_id_table := player_id_table();
  
  -- Before each row section
  BEFORE EACH ROW IS
  BEGIN
    -- Determine the type of DML operation
    IF INSERTING THEN
      v_dml_type := 'INSERT';
      v_player_ids.EXTEND; -- Extend the collection by one
      v_player_ids(v_player_ids.LAST) := :NEW.player_id; -- Add the new player_id to the collection
    ELSIF UPDATING THEN
      v_dml_type := 'UPDATE';
      v_player_ids.EXTEND; -- Extend the collection by one
      v_player_ids(v_player_ids.LAST) := :NEW.player_id; -- Add the new player_id to the collection
    ELSIF DELETING THEN
      v_dml_type := 'DELETE';
      v_player_ids.EXTEND; -- Extend the collection by one
      v_player_ids(v_player_ids.LAST) := :OLD.player_id; -- Add the old player_id to the collection
    END IF;
  END BEFORE EACH ROW;

  -- After statement section
  AFTER STATEMENT IS
  BEGIN
    FOR i IN 1 .. v_player_ids.COUNT LOOP
      -- Use a MERGE statement to update or insert into player_stats
      MERGE INTO player_stats ps
      USING (
        SELECT player_id, SUM(games_played) AS total_games, SUM(points_scored) AS total_points
        FROM players
        WHERE player_id = v_player_ids(i)
        GROUP BY player_id
      ) src
      ON (ps.player_id = src.player_id)
      WHEN MATCHED THEN
        UPDATE SET ps.total_games = src.total_games, ps.total_points = src.total_points
      WHEN NOT MATCHED THEN
        INSERT (player_id, total_games, total_points)
        VALUES (src.player_id, src.total_games, src.total_points);
    END LOOP;

    -- Print the type of DML operation for demonstration purposes
    DBMS_OUTPUT.PUT_LINE('DML Operation Type: ' || v_dml_type);
  END AFTER STATEMENT;

END trg_player_stats;




-- Insert a new player
INSERT INTO players (player_id, player_name, games_played, points_scored)
VALUES (1, 'John Doe', 10, 150);


SELECT * FROM players;
-- Check the player_stats table
SELECT * FROM player_stats;

-- Update the player's statistics
UPDATE players SET games_played = 15, points_scored = 200 WHERE player_id = 1;

-- Check the player_stats table
SELECT * FROM player_stats;

-- Delete the player
DELETE FROM players WHERE player_id = 1;

-- Check the player_stats table
SELECT * FROM player_stats;




    





Create or replace package manage_students
as
    procedure find_sname
        (i_student_id in student.student_id%type,
        o_first_name out student.first_name%Type,
        o_last_name out student.last_name%type
        );
    Function id_is_good
        (i_student_id in student.student_id%type)
        Return boolean;
End manage_students;

Declare
    v_first_name student.first_name%TYPE;
    v_last_Name student.last_name%Type;
    
BEGIN
    manage_students.find_sname
        (125, v_first_name, v_last_nae);
    Dbms_output.put_line(v_first_name || ' ' || v_last_name);












for banking system,
if emp want to deposit or withdraw the amount then he needs to see the statement, 











































